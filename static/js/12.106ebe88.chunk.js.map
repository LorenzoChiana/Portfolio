{"version":3,"sources":["assets/arrow-left.svg","assets/arrow-right.svg","components/Carousel/index.js","components/Carousel/carouselShader.js","utils/three.js","utils/image.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_ref","createElement","d","SvgArrowLeft","svgRef","title","props","fill","width","height","viewBox","ref","ForwardRef","forwardRef","SvgArrowRight","determineIndex","imageIndex","index","images","direction","Carousel","placeholder","rest","setImageIndex","useState","loaded","setLoaded","showPlaceholder","setShowPlaceholder","textures","setTextures","canvasRect","setCanvasRect","canvas","useRef","imagePlane","geometry","material","scene","camera","renderer","animating","swipeDirection","lastSwipePosition","scheduledAnimationFrame","prefersReducedMotion","usePrefersReducedMotion","inViewport","useInViewport","placeholderRef","springTween","springValue","swipeElement","currentImageAlt","alt","useEffect","cameraOptions","current","WebGLRenderer","antialias","OrthographicCamera","Scene","setPixelRatio","renderPixelRatio","setClearColor","setSize","domElement","style","background","Color","position","z","cleanScene","cleanRenderer","mounted","async","textureLoader","TextureLoader","anisotropy","capabilities","getMaxAnisotropy","texturePromises","map","imageSrc","getImageFromSrcSet","image","imageTexture","loadAsync","initTexture","encoding","sRGBEncoding","minFilter","LinearFilter","magFilter","generateMipmaps","Promise","all","ShaderMaterial","uniforms","dispFactor","type","value","currentImage","nextImage","vertexShader","fragmentShader","transparent","opacity","PlaneBufferGeometry","Mesh","set","add","requestAnimationFrame","render","loadImages","goToIndex","useCallback","onComplete","spring","from","get","to","velocity","getVelocity","stiffness","damping","start","navigate","cancelAnimationFrame","finalIndex","onNavClick","handleResize","rect","getBoundingClientRect","window","addEventListener","removeEventListener","animation","animate","stop","purgePlaceholder","placeholderElement","onSwipeMove","x","absoluteX","Math","abs","containerWidth","swipePercentage","nextIndex","displacementClamp","min","max","onSwipeEnd","duration","minSwipeDistance","pointerTracker","swipeXY","y","swipeStart","listen","event","preventDefault","pointer","swipeEnd","document","className","onKeyDown","selectedAction","ArrowRight","ArrowLeft","aria-atomic","aria-live","aria-label","role","aria-hidden","classNames","prerender","src","onClick","onMouseUp","blurOnMouseUp","aria-pressed","traverse","object","isMesh","dispose","isMaterial","cleanMaterial","keys","forceContextLoss","removeLights","lights","light","parent","remove","srcSet","sizes","resolve","reject","Error","tempImage","Image","srcset","onLoad","currentSrc","error"],"mappings":"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","file":"static/js/12.106ebe88.chunk.js","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref = /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M18.03 1.375L16.47.125-.031 20.75l16.5 20.625 1.562-1.25L2.53 20.75z\"\n});\n\nconst SvgArrowLeft = ({\n  svgRef,\n  title,\n  ...props\n}) => /*#__PURE__*/React.createElement(\"svg\", _extends({\n  fill: \"currentColor\",\n  width: 18,\n  height: 42,\n  viewBox: \"0 0 18 42\",\n  ref: svgRef\n}, props), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, _ref);\n\nconst ForwardRef = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(SvgArrowLeft, _extends({\n  svgRef: ref\n}, props)));\nexport default __webpack_public_path__ + \"static/media/arrow-left.a44fa029.svg\";\nexport { ForwardRef as ReactComponent };","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\n\nvar _ref = /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M-.03 1.375L1.53.125l16.5 20.625-16.5 20.625-1.562-1.25 15.5-19.375z\"\n});\n\nconst SvgArrowRight = ({\n  svgRef,\n  title,\n  ...props\n}) => /*#__PURE__*/React.createElement(\"svg\", _extends({\n  fill: \"currentColor\",\n  width: 18,\n  height: 42,\n  viewBox: \"0 0 18 42\",\n  ref: svgRef\n}, props), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, _ref);\n\nconst ForwardRef = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(SvgArrowRight, _extends({\n  svgRef: ref\n}, props)));\nexport default __webpack_public_path__ + \"static/media/arrow-right.0072412b.svg\";\nexport { ForwardRef as ReactComponent };","import React, { useState, useEffect, useRef, useCallback } from 'react';\r\nimport {\r\n  WebGLRenderer,\r\n  LinearFilter,\r\n  OrthographicCamera,\r\n  Scene,\r\n  PlaneBufferGeometry,\r\n  TextureLoader,\r\n  ShaderMaterial,\r\n  Mesh,\r\n  Color,\r\n  sRGBEncoding,\r\n} from 'three';\r\nimport { spring, value, listen, pointer } from 'popmotion';\r\nimport classNames from 'classnames';\r\nimport { usePrefersReducedMotion, useInViewport } from 'hooks';\r\nimport prerender from 'utils/prerender';\r\nimport { blurOnMouseUp } from 'utils/focus';\r\nimport { ReactComponent as ArrowLeft } from 'assets/arrow-left.svg';\r\nimport { ReactComponent as ArrowRight } from 'assets/arrow-right.svg';\r\nimport { vertex, fragment } from './carouselShader';\r\nimport { cleanScene, cleanRenderer, renderPixelRatio } from 'utils/three';\r\nimport { getImageFromSrcSet } from 'utils/image';\r\nimport './index.css';\r\n\r\nfunction determineIndex(imageIndex, index, images, direction) {\r\n  if (index !== null) return index;\r\n  const length = images.length;\r\n  const prevIndex = (imageIndex - 1 + length) % length;\r\n  const nextIndex = (imageIndex + 1) % length;\r\n  const finalIndex = direction > 0 ? nextIndex : prevIndex;\r\n  return finalIndex;\r\n}\r\n\r\nconst Carousel = ({ width, height, images, placeholder, ...rest }) => {\r\n  const [imageIndex, setImageIndex] = useState(0);\r\n  const [loaded, setLoaded] = useState(false);\r\n  const [showPlaceholder, setShowPlaceholder] = useState(true);\r\n  const [textures, setTextures] = useState();\r\n  const [canvasRect, setCanvasRect] = useState();\r\n  const canvas = useRef();\r\n  const imagePlane = useRef();\r\n  const geometry = useRef();\r\n  const material = useRef();\r\n  const scene = useRef();\r\n  const camera = useRef();\r\n  const renderer = useRef();\r\n  const animating = useRef(false);\r\n  const swipeDirection = useRef();\r\n  const lastSwipePosition = useRef();\r\n  const scheduledAnimationFrame = useRef();\r\n  const prefersReducedMotion = usePrefersReducedMotion();\r\n  const inViewport = useInViewport(canvas, true);\r\n  const placeholderRef = useRef();\r\n  const springTween = useRef();\r\n  const springValue = useRef();\r\n  const swipeElement = useRef();\r\n\r\n  const currentImageAlt = `Slide ${imageIndex + 1} of ${images.length}. ${\r\n    images[imageIndex].alt\r\n  }`;\r\n\r\n  useEffect(() => {\r\n    const cameraOptions = [width / -2, width / 2, height / 2, height / -2, 1, 1000];\r\n    renderer.current = new WebGLRenderer({ canvas: canvas.current, antialias: false });\r\n    camera.current = new OrthographicCamera(...cameraOptions);\r\n    scene.current = new Scene();\r\n    renderer.current.setPixelRatio(renderPixelRatio);\r\n    renderer.current.setClearColor(0x111111, 1.0);\r\n    renderer.current.setSize(width, height);\r\n    renderer.current.domElement.style.width = '100%';\r\n    renderer.current.domElement.style.height = 'auto';\r\n    scene.current.background = new Color(0x111111);\r\n    camera.current.position.z = 1;\r\n\r\n    return () => {\r\n      animating.current = false;\r\n      cleanScene(scene.current);\r\n      cleanRenderer(renderer.current);\r\n    };\r\n  }, [height, width]);\r\n\r\n  useEffect(() => {\r\n    let mounted = true;\r\n\r\n    const loadImages = async () => {\r\n      const textureLoader = new TextureLoader();\r\n      const anisotropy = renderer.current.capabilities.getMaxAnisotropy();\r\n\r\n      const texturePromises = images.map(async image => {\r\n        const imageSrc = await getImageFromSrcSet(image);\r\n        const imageTexture = await textureLoader.loadAsync(imageSrc);\r\n        await renderer.current.initTexture(imageTexture);\r\n        imageTexture.encoding = sRGBEncoding;\r\n        imageTexture.minFilter = LinearFilter;\r\n        imageTexture.magFilter = LinearFilter;\r\n        imageTexture.anisotropy = anisotropy;\r\n        imageTexture.generateMipmaps = false;\r\n        return imageTexture;\r\n      });\r\n\r\n      const textures = await Promise.all(texturePromises);\r\n\r\n      // Cancel if the component has unmounted during async code\r\n      if (!mounted) return;\r\n\r\n      material.current = new ShaderMaterial({\r\n        uniforms: {\r\n          dispFactor: { type: 'f', value: 0 },\r\n          direction: { type: 'f', value: 1 },\r\n          currentImage: { type: 't', value: textures[0] },\r\n          nextImage: { type: 't', value: textures[1] },\r\n        },\r\n        vertexShader: vertex,\r\n        fragmentShader: fragment,\r\n        transparent: false,\r\n        opacity: 1,\r\n      });\r\n\r\n      geometry.current = new PlaneBufferGeometry(width, height, 1);\r\n      imagePlane.current = new Mesh(geometry.current, material.current);\r\n      imagePlane.current.position.set(0, 0, 0);\r\n      scene.current.add(imagePlane.current);\r\n\r\n      setLoaded(true);\r\n      setTextures(textures);\r\n\r\n      requestAnimationFrame(() => {\r\n        renderer.current.render(scene.current, camera.current);\r\n      });\r\n    };\r\n\r\n    if (inViewport && !loaded) {\r\n      loadImages();\r\n    }\r\n\r\n    return () => {\r\n      mounted = false;\r\n    };\r\n  }, [height, images, inViewport, loaded, width]);\r\n\r\n  const goToIndex = useCallback(\r\n    ({ index, direction = 1 }) => {\r\n      if (!textures) return;\r\n      setImageIndex(index);\r\n      const uniforms = material.current.uniforms;\r\n      uniforms.nextImage.value = textures[index];\r\n      uniforms.direction.value = direction;\r\n\r\n      const onComplete = () => {\r\n        uniforms.currentImage.value = textures[index];\r\n        uniforms.dispFactor.value = 0;\r\n        animating.current = false;\r\n      };\r\n\r\n      if (!prefersReducedMotion && uniforms.dispFactor.value !== 1) {\r\n        animating.current = true;\r\n\r\n        springValue.current = value(uniforms.dispFactor.value, value => {\r\n          uniforms.dispFactor.value = value;\r\n          if (value === 1) onComplete();\r\n        });\r\n\r\n        springTween.current = spring({\r\n          from: springValue.current.get(),\r\n          to: 1,\r\n          velocity: springValue.current.getVelocity(),\r\n          stiffness: 100,\r\n          damping: 20,\r\n        }).start(springValue.current);\r\n      } else {\r\n        onComplete();\r\n        requestAnimationFrame(() => {\r\n          renderer.current.render(scene.current, camera.current);\r\n        });\r\n      }\r\n    },\r\n    [prefersReducedMotion, textures]\r\n  );\r\n\r\n  const navigate = useCallback(\r\n    ({ direction, index = null, ...rest }) => {\r\n      if (!loaded) return;\r\n\r\n      if (animating.current) {\r\n        cancelAnimationFrame(scheduledAnimationFrame.current);\r\n        scheduledAnimationFrame.current = requestAnimationFrame(() =>\r\n          navigate({ direction, index, ...rest })\r\n        );\r\n        return;\r\n      }\r\n\r\n      const finalIndex = determineIndex(imageIndex, index, textures, direction);\r\n      goToIndex({ index: finalIndex, direction: direction, ...rest });\r\n    },\r\n    [goToIndex, imageIndex, loaded, textures]\r\n  );\r\n\r\n  const onNavClick = useCallback(\r\n    index => {\r\n      if (index === imageIndex) return;\r\n      const direction = index > imageIndex ? 1 : -1;\r\n      navigate({ direction, index });\r\n    },\r\n    [imageIndex, navigate]\r\n  );\r\n\r\n  useEffect(() => {\r\n    const handleResize = () => {\r\n      const rect = canvas.current.getBoundingClientRect();\r\n      setCanvasRect(rect);\r\n    };\r\n\r\n    window.addEventListener('resize', handleResize);\r\n    handleResize();\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n    };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    let animation;\r\n\r\n    const animate = () => {\r\n      animation = requestAnimationFrame(animate);\r\n      if (animating.current) {\r\n        renderer.current.render(scene.current, camera.current);\r\n      }\r\n    };\r\n\r\n    animation = requestAnimationFrame(animate);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(animation);\r\n\r\n      if (springTween.current) {\r\n        springTween.current.stop();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (placeholder) {\r\n      const purgePlaceholder = () => {\r\n        setShowPlaceholder(false);\r\n      };\r\n\r\n      const placeholderElement = placeholderRef.current;\r\n      placeholderElement.addEventListener('transitionend', purgePlaceholder);\r\n\r\n      return () => {\r\n        if (placeholderElement) {\r\n          placeholderElement.removeEventListener('transitionend', purgePlaceholder);\r\n        }\r\n      };\r\n    }\r\n  }, [placeholder]);\r\n\r\n  const onSwipeMove = useCallback(\r\n    position => {\r\n      if (animating.current || !material.current || !textures) return;\r\n      const { x } = position;\r\n      lastSwipePosition.current = x;\r\n      const absoluteX = Math.abs(x);\r\n      const containerWidth = canvasRect.width;\r\n      swipeDirection.current = x > 0 ? -1 : 1;\r\n      const swipePercentage = 1 - ((absoluteX - containerWidth) / containerWidth) * -1;\r\n      const nextIndex = determineIndex(imageIndex, null, images, swipeDirection.current);\r\n      const uniforms = material.current.uniforms;\r\n      const displacementClamp = Math.min(Math.max(swipePercentage, 0), 1);\r\n\r\n      uniforms.currentImage.value = textures[imageIndex];\r\n      uniforms.nextImage.value = textures[nextIndex];\r\n      uniforms.direction.value = swipeDirection.current;\r\n\r\n      if (!prefersReducedMotion) {\r\n        uniforms.dispFactor.value = displacementClamp;\r\n      }\r\n\r\n      requestAnimationFrame(() => {\r\n        renderer.current.render(scene.current, camera.current);\r\n      });\r\n    },\r\n    [canvasRect, imageIndex, images, prefersReducedMotion, textures]\r\n  );\r\n\r\n  const onSwipeEnd = useCallback(() => {\r\n    if (!material.current) return;\r\n    const uniforms = material.current.uniforms;\r\n    const duration = (1 - uniforms.dispFactor.value) * 1000;\r\n    const position = Math.abs(lastSwipePosition.current);\r\n    const minSwipeDistance = canvasRect.width * 0.2;\r\n    lastSwipePosition.current = 0;\r\n\r\n    if (animating.current) return;\r\n    if (position === 0 || !position) return;\r\n\r\n    if (position > minSwipeDistance) {\r\n      navigate({\r\n        duration,\r\n        direction: swipeDirection.current,\r\n      });\r\n    } else {\r\n      uniforms.currentImage.value = uniforms.nextImage.value;\r\n      uniforms.nextImage.value = uniforms.currentImage.value;\r\n      uniforms.dispFactor.value = 1 - uniforms.dispFactor.value;\r\n\r\n      navigate({\r\n        direction: swipeDirection.current * -1,\r\n        index: imageIndex,\r\n      });\r\n    }\r\n  }, [canvasRect, imageIndex, navigate]);\r\n\r\n  useEffect(() => {\r\n    let pointerTracker;\r\n\r\n    const swipeXY = value({ x: 0, y: 0 }, position => {\r\n      onSwipeMove(position);\r\n    });\r\n\r\n    const swipeStart = listen(swipeElement.current, 'mousedown touchstart').start(\r\n      event => {\r\n        event.preventDefault();\r\n        pointerTracker = pointer({ x: 0, y: 0 }).start(swipeXY);\r\n      }\r\n    );\r\n\r\n    const swipeEnd = listen(document, 'mouseup touchend').start(() => {\r\n      if (pointerTracker) {\r\n        onSwipeEnd();\r\n        pointerTracker.stop();\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      swipeStart.stop();\r\n      swipeEnd.stop();\r\n\r\n      if (pointerTracker) {\r\n        pointerTracker.stop();\r\n      }\r\n    };\r\n  }, [onSwipeEnd, onSwipeMove]);\r\n\r\n  const handleKeyDown = event => {\r\n    const actions = {\r\n      ArrowRight: () => navigate({ direction: 1 }),\r\n      ArrowLeft: () => navigate({ direction: -1 }),\r\n    };\r\n\r\n    const selectedAction = actions[event.key];\r\n\r\n    if (!!selectedAction) {\r\n      selectedAction();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"carousel\" onKeyDown={handleKeyDown} {...rest}>\r\n      <div className=\"carousel__content\">\r\n        <div className=\"carousel__image-wrapper\" ref={swipeElement}>\r\n          <div\r\n            aria-atomic\r\n            className=\"carousel__canvas-wrapper\"\r\n            aria-live=\"polite\"\r\n            aria-label={currentImageAlt}\r\n            role=\"img\"\r\n          >\r\n            <canvas aria-hidden className=\"carousel__canvas\" ref={canvas} />\r\n          </div>\r\n          {showPlaceholder && placeholder && (\r\n            <img\r\n              aria-hidden\r\n              className={classNames('carousel__placeholder', {\r\n                'carousel__placeholder--loaded': !prerender && loaded && textures,\r\n              })}\r\n              src={placeholder}\r\n              ref={placeholderRef}\r\n              alt=\"\"\r\n              role=\"presentation\"\r\n            />\r\n          )}\r\n        </div>\r\n        <button\r\n          className=\"carousel__button carousel__button--prev\"\r\n          aria-label=\"Previous slide\"\r\n          onClick={() => navigate({ direction: -1 })}\r\n          onMouseUp={blurOnMouseUp}\r\n        >\r\n          <ArrowLeft />\r\n        </button>\r\n        <button\r\n          className=\"carousel__button carousel__button--next\"\r\n          aria-label=\"Next slide\"\r\n          onClick={() => navigate({ direction: 1 })}\r\n          onMouseUp={blurOnMouseUp}\r\n        >\r\n          <ArrowRight />\r\n        </button>\r\n      </div>\r\n      <div className=\"carousel__nav\">\r\n        {images.map((image, index) => (\r\n          <button\r\n            className=\"carousel__nav-button\"\r\n            key={image.alt}\r\n            onClick={() => onNavClick(index)}\r\n            onMouseUp={blurOnMouseUp}\r\n            aria-label={`Jump to slide ${index + 1}`}\r\n            aria-pressed={index === imageIndex}\r\n          />\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Carousel;\r\n","export const vertex = `\r\n  varying vec2 vUv;\r\n  void main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n  }\r\n`;\r\n\r\nexport const fragment = `\r\n  varying vec2 vUv;\r\n  uniform sampler2D currentImage;\r\n  uniform sampler2D nextImage;\r\n  uniform float dispFactor;\r\n  uniform float direction;\r\n\r\n  void main() {\r\n    vec2 uv = vUv;\r\n    vec4 _currentImage;\r\n    vec4 _nextImage;\r\n    float intensity = 0.6;\r\n\r\n    vec4 orig1 = texture2D(currentImage, uv);\r\n    vec4 orig2 = texture2D(nextImage, uv);\r\n\r\n    vec2 distortedPosition = vec2(\r\n      uv.x + direction * (dispFactor * (orig2.r * intensity)),\r\n      uv.y + direction * (dispFactor * (orig2 * intensity))\r\n    );\r\n\r\n    vec2 distortedPosition2 = vec2(\r\n      uv.x - direction * ((1.0 - dispFactor) * (orig1.r * intensity)),\r\n      uv.y - direction * ((1.0 - dispFactor) * (orig1 * intensity))\r\n    );\r\n\r\n    _currentImage = texture2D(currentImage, distortedPosition);\r\n    _nextImage = texture2D(nextImage, distortedPosition2);\r\n\r\n    vec4 finalTexture = mix(_currentImage, _nextImage, dispFactor);\r\n    gl_FragColor = finalTexture;\r\n  }\r\n`;\r\n","/**\r\n * Clean up a scene's materials and geometry\r\n */\r\nexport const cleanScene = scene => {\r\n  scene.traverse(object => {\r\n    if (!object.isMesh) return;\r\n\r\n    object.geometry.dispose();\r\n\r\n    if (object.material.isMaterial) {\r\n      cleanMaterial(object.material);\r\n    } else {\r\n      for (const material of object.material) {\r\n        cleanMaterial(material);\r\n      }\r\n    }\r\n  });\r\n\r\n  scene.dispose();\r\n};\r\n\r\n/**\r\n * Clean up and dispose of a material\r\n */\r\nexport const cleanMaterial = material => {\r\n  material.dispose();\r\n\r\n  for (const key of Object.keys(material)) {\r\n    const value = material[key];\r\n    if (value && typeof value === 'object' && 'minFilter' in value) {\r\n      value.dispose();\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Clean up and dispose of a renderer\r\n */\r\nexport const cleanRenderer = renderer => {\r\n  renderer.dispose();\r\n  renderer.forceContextLoss();\r\n  renderer = null;\r\n};\r\n\r\n/**\r\n * Clean up lights by removing them from their parent\r\n */\r\nexport const removeLights = lights => {\r\n  for (const light of lights) {\r\n    light.parent.remove(light);\r\n  }\r\n};\r\n\r\n/**\r\n * A reasonable default pixel ratio\r\n */\r\nexport const renderPixelRatio = 2;\r\n","/**\r\n * Uses the browser's image loading to get the correct image src from a srcSet\r\n */\r\nexport async function getImageFromSrcSet({ src, srcSet, sizes }) {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      if (!src && !srcSet) {\r\n        throw new Error('No image src or srcSet provided');\r\n      }\r\n\r\n      const tempImage = new Image();\r\n\r\n      if (src) {\r\n        tempImage.src = src;\r\n      }\r\n\r\n      if (srcSet) {\r\n        tempImage.srcset = srcSet;\r\n      }\r\n\r\n      if (sizes) {\r\n        tempImage.sizes = sizes;\r\n      }\r\n\r\n      const onLoad = () => {\r\n        tempImage.removeEventListener('load', onLoad);\r\n        const source = tempImage.currentSrc;\r\n        resolve(source);\r\n      };\r\n\r\n      tempImage.addEventListener('load', onLoad);\r\n    } catch (error) {\r\n      reject(`Error loading ${srcSet}: ${error}`);\r\n    }\r\n  });\r\n}\r\n"],"sourceRoot":""}